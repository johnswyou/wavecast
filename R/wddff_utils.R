# This function determines the way in which target and input data is used
# in subsequent functions within the WDDFF based on the type of wavelet-
# or non-wavelet-based forecasting model.

# Input(s):
# @param pd_list - list generated by 'prepareData.R' that contains target and input data
# (which may include their wavelet-based counterpats) and the type of
# wavelet- (or non-wavelet-) based forecasting method.
# @param max_decomp_level - maximum decomposition level [scalar >= decomp_level]
# @param max_wavelet_length - maxmimum wavelet filter length [scalar >= length(wavelet)]

# Output:
# list that contains input-output datasets based on type of wavelet-based
# forecasting model (i.e., single, single-hyrbid, within, etc.) according
# to Quilty and Adamowski (2018)

# Reference(s):
# Quilty, J., and J. Adamowski (2018), Addressing the incorrect usage of wavelet-
# based hydrological and water resources forecasting models for real-world
# applications with best practices and a new forecasting framework, J. Hydrol.,
# doi:10.1016/j.jhydrol.2018.05.003.
#' @keywords internal
organizeIOData <- function(pd_list,max_decomp_level,
                           max_wavelet_length){

  # number of boundary coefficients to correct
  nbc = ((2^max_decomp_level) - 1) * (max_wavelet_length - 1) + 1;

  switch(pd_list$wfm,

         # none

         none={

           IO = list()
           IO[[1]] = bindYX(pd_list$target,pd_list$inputs)


         },

         # single - applicable with AT and MODWT

         single={

           IO = list()
           IO[[1]] = bindYX(pd_list$target,pd_list$Winputs)


         },

         # within - applicable with AT only

         within={

           IO = list()

           for(j in 1:length(pd_list$wlevels)){

             Wt = stats::setNames(data.frame(
               pd_list$Wtarget[ ,
                                grepl(pd_list$wlevels[j] ,
                                      names( pd_list$Wtarget) ) ]),
               names(pd_list$Wtarget)[grepl(pd_list$wlevels[j] ,
                                            names( pd_list$Wtarget) )])

             Wi = stats::setNames(data.frame(
               pd_list$Winputs[ ,
                                grepl(pd_list$wlevels[j] ,
                                      names( pd_list$Winputs) ) ]),
               names(pd_list$Winputs)[grepl(pd_list$wlevels[j] ,
                                            names( pd_list$Winputs) )])
             IO[[j]] = bindYX(Wt,Wi)

           }

         },

         # across - applicable with AT onnly

         across={

           IO = list()

           for(j in 1:length(pd_list$wlevels)){

             Wt = stats::setNames(data.frame(
               pd_list$Wtarget[ ,
                                grepl(pd_list$wlevels[j] ,
                                      names( pd_list$Wtarget) ) ]),
               names(pd_list$Wtarget)[grepl(pd_list$wlevels[j] ,
                                            names( pd_list$Wtarget) )])
             IO[[j]] = bindYX(Wt,pd_list$Winputs)

           }

         },

         # single_hybrid - applicable with AT and MODWT

         single_hybrid={

           IO = list()
           IO[[1]] = bindYXZ(pd_list$target,pd_list$inputs,pd_list$Winputs)


         },

         # within_hybrid - applicable with AT only

         within_hybrid={

           IO = list()

           for(j in 1:length(pd_list$wlevels)){

             Wt = stats::setNames(data.frame(
               pd_list$Wtarget[ ,
                                grepl(pd_list$wlevels[j] ,
                                      names( pd_list$Wtarget) ) ]),
               names(pd_list$Wtarget)[grepl(pd_list$wlevels[j] ,
                                            names( pd_list$Wtarget) )])

             Wi = stats::setNames(data.frame(
               pd_list$Winputs[ ,
                                grepl(pd_list$wlevels[j] ,
                                      names( pd_list$Winputs) ) ]),
               names(pd_list$Winputs)[grepl(pd_list$wlevels[j] ,
                                            names( pd_list$Winputs) )])
             IO[[j]] = bindYXZ(Wt,pd_list$inputs,Wi)

           }

         },

         # across_hybrid - applicable with AT onnly

         across_hybrid={

           IO = list()

           for(j in 1:length(pd_list$wlevels)){

             Wt = stats::setNames(data.frame(
               pd_list$Wtarget[ ,
                                grepl(pd_list$wlevels[j] ,
                                      names( pd_list$Wtarget) ) ]),
               names(pd_list$Wtarget)[grepl(pd_list$wlevels[j] ,
                                            names( pd_list$Wtarget) )])
             IO[[j]] = bindYXZ(Wt,pd_list$inputs,pd_list$Winputs)

           }

         }

  )

  # remove boundary-effected coefficients

  if(nbc > 0 ){

    IO = lapply(IO, function(x) x[-(1:nbc),])

  }

  return(IO)

}

# ------------------------------------------------------------------------------

# This function determines the way in which target and input data is used
# in subsequent functions within the WDDFF based on the type of wavelet-
# or non-wavelet-based forecasting model.

# Input(s):
# @param y: time series [N x 1]
# @param x: input time series [N x D]
# @param z: auxilliary input time series [N x C]
# @param leadtime: forecast lead time [scalar >= 0]
# @param lag_Y: number of time delays for target [scalar >= 1]
# @param lag_X: number of time delays [vector (or scalar >= 1)]
# @param wfm - wavelet-based forecasting method [string: 'none', 'single', 'within', 'across','single-hybrid','within-hybrid','across-hybrid']
# @param wt - type of wavelet transform [string; 'at','modwt']
# @param wavelet - scaling filter name [string]
# @param decomp_level - decomposition level [1 < integer << N/2]

# Output:
# list containing target and input data (which may include their wavelet-based
# counterpats)
#' @keywords internal
prepareData <- function(y,x=NULL,z=NULL,
                        leadtime,lag_Y,lag_X,
                        wfm='none',wt='at',wavelet='haar',decomp_level=1){

  ###########################################################################################
  #' CHECK INPUTS AND SET COLUMN NAMES FOR DIFFERENT VARIABLES
  ###########################################################################################

  y = as.matrix(y)
  colnames(y) = 'y'

  isxnull = is.null(x) # check if standard inputs were provided
  if ( !isxnull ){ # inputs provided

    x = as.matrix(x)
    N = nrow(x)
    D = ncol(x)
    colnames(x) = paste0('x',1:ncol(x))

  }

  isznull = is.null(z) # check if auxilliary inputs were provided
  if ( !isznull ){ # inputs provided

    z = as.matrix(z)
    N = nrow(z)
    C = ncol(z)
    colnames(z) = paste0('z',1:ncol(z))

  }

  ###########################################################################################
  #' perform time lag of target (and potentially standard inputs; note: auxulliary
  #' inputs are not time-lagged)
  ###########################################################################################

  # target

  yltd = yLTD(y,leadtime,lag_Y)

  # inputs

  if (!isxnull){ # standard inputs provided (note: auxulliary inputs are not time-lagged)

    xltd = xLTD(x,leadtime,lag_X)

  }

  ###########################################################################################
  #' if needed perform wavelet decomposition on target and inputs (but not auxilliary
  #' inputs...)
  ###########################################################################################

  if(wfm != 'none'){ # case where wavelet decomposition is needed

    # perform wavelet decomposition on target

    Wy = waveletDecomp(y,wt,wavelet,decomp_level)
    colnames(Wy) = c(paste0(colnames(y),'_',"W", 1:(ncol(Wy)-1)),
                     paste0(colnames(y),'_',"V", ncol(Wy)-1))
    Wy = as.data.frame(Wy)

    wlevels = c(paste0("W", 1:(ncol(Wy)-1)),paste0("V", ncol(Wy)-1)) # colname of wavelet and scaling coefs

    # perform wavelet decomposition on inputs (if any)... but not auxilliary inputs

    if (!isxnull){ # inputs provided

      # preallocate space
      Wx = vector(mode = "list",D)

      for (i in 1:D){

        xi = as.matrix(x[,i])
        Wxtmp = waveletDecomp(xi,wt,wavelet,decomp_level)
        colnames(Wxtmp) = c(paste0(colnames(x)[i],'_',"W", 1:(ncol(Wxtmp)-1)),
                            paste0(colnames(x)[i],'_',"V", ncol(Wxtmp)-1))
        Wx[[i]] = Wxtmp

      }

      Wx = as.data.frame(do.call(cbind,Wx))

    }

    # wavelet decomposed target lead time

    Wylt = Wy
    colnames(Wylt) = paste0(colnames(Wy),'_',0)

    # perform time lag of wavelet-decomposed data

    # wavelet-decomposed target

    # Wytd = xLeadTimeDelay(Wy,leadtime,lag_Y)
    Wytd = xLTD(Wy,leadtime,lag_Y)

    # wavelet-decomposed inputs (if any)

    if (!isxnull){ # inputs provided

      # Wxtd = xLeadTimeDelay(Wx,leadtime,lag_X)
      Wxtd = xLTD(Wx,leadtime,lag_X)

    }

  }

  ###########################################################################################
  #' output required data
  ###########################################################################################

  if(wfm != 'none'){ # when wavelet decomposition is used

    target = as.data.frame(yltd[,1])
    colnames(target) = colnames(yltd)[1]
    Wtarget = Wylt
    colnames(Wtarget) = colnames(Wylt)

    if( !isxnull ){ # standard inputs provided

      inputs = as.data.frame(cbind(yltd[,-1],xltd))
      colnames(inputs) = c(colnames(yltd)[-1],colnames(xltd))

      if( !isznull ){ # auxilliary inputs provided

        inputs = as.data.frame(cbind(yltd[,-1],xltd,z))
        colnames(inputs) = c(colnames(yltd)[-1],colnames(xltd),colnames(z))

      }

      if( (leadtime > 0) & (lag_Y > 0) ){

        Winputs = cbind(Wytd,Wxtd)
        colnames(Winputs) = c(colnames(Wytd),colnames(Wxtd))


      }

      else{

        Winputs = Wxtd
        colnames(Winputs) = colnames(Wxtd)

      }

      return(list(
        target = target,
        Wtarget = Wtarget,
        inputs = inputs,
        Winputs = Winputs,
        wlevels = wlevels,
        wfm = wfm
      ))

    }


    else{ # standard inputs NOT provided

      inputs = as.data.frame(yltd[,-1])
      colnames(inputs) = colnames(yltd)[-1]

      if( !isznull ){ # auxilliary inputs provided

        inputs = as.data.frame(cbind(yltd[,-1],z))
        colnames(inputs) = c(colnames(yltd)[-1],colnames(z))

      }

      if( (leadtime>0) & (lag_Y > 0) ){

        Winputs = Wytd
        colnames(Winputs) = c(colnames(Wytd))


        return(list(
          target = target,
          Wtarget = Wtarget,
          inputs = inputs,
          Winputs = Winputs,
          wlevels = wlevels,
          wfm = wfm
        ))

      }

      else{

        return(list(
          target = target,
          Wtarget = Wtarget,
          inputs = inputs,
          wlevels = wlevels,
          wfm = wfm
        ))

      }

    }

  }

  else{ # wavelet decomposition not needed

    target = as.data.frame(yltd[,1])
    colnames(target) = colnames(yltd)[1]

    if (!isxnull){ # inputs provided

      inputs = as.data.frame(cbind(yltd[,-1],xltd))
      colnames(inputs) = c(colnames(yltd)[-1],colnames(xltd))

      if( !isznull ){ # auxilliary inputs provided

        inputs = as.data.frame(cbind(yltd[,-1],xltd,z))
        colnames(inputs) = c(colnames(yltd)[-1],colnames(xltd),colnames(z))

      }

      return(list(
        target = target,
        inputs = inputs,
        wfm = wfm
      ))

    }

    else{ # no inputs provided

      inputs = as.data.frame(yltd[,-1])
      colnames(inputs) = colnames(yltd)[-1]

      if( !isznull ){ # auxilliary inputs provided

        inputs = as.data.frame(cbind(yltd[,-1],z))
        colnames(inputs) = c(colnames(yltd)[-1],colnames(z))

      }

      return(list(
        target = target,
        inputs = inputs,
        wfm = wfm
      ))

    }

  }

} # EOF...

# ------------------------------------------------------------------------------

#' @title Wavelet Decomposition
#' @description
#' This function performs wavelet decomposition using either the maximal
#' overlap discrete wavelet transform (MODWT) or the à trous (AT) algorithm.
#' @param y time series \[N x 1\]
#' @param wt type of wavelet transform \[string; 'at','modwt'\], Default: 'modwt'
#' @param wavelet scaling filter name \[string\], Default: 'haar'
#' @param decomp_level decomposition level \[1 < integer << N/2\], Default: 1
#' @return wavelet and scaling coefficients \[N x D x J+1\] (wavelet coefs in first J columns, scaling coefs in last column)
#' @references
#' Quilty, J., and J. Adamowski (2018), Addressing the incorrect usage of wavelet-
#' based hydrological and water resources forecasting models for real-world
#' applications with best practices and a new forecasting framework, J. Hydrol.,
#' doi:10.1016/j.jhydrol.2018.05.003.
#' @rdname waveletDecomp
#' @export
waveletDecomp <- function(y,wt='modwt',wavelet='haar',decomp_level=1){

  #y = as.matrix(y)

  switch(wt,

         # AT

         at={

           W = fastWavelets::atrous_dwt(y,wavelet,decomp_level) # use AT algoritm

         },

         # MODWT

         modwt={

           W = fastWavelets::mo_dwt(y,wavelet,decomp_level) # use MODWT algoritm

         }

  )

  return(as.data.frame(W))

}
